# coding: utf-8

"""
    Wavenet Connected API

    Provides a primary resource for buildings, room tenancies for Wavenet connected customers, includes other information such as VLAN information and addresses

    The version of the OpenAPI document: 2.5.x
    Contact: development@wavenetuk.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import date, datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Any, Optional

from openapi_client.models.building import Building
from openapi_client.models.building_operator import BuildingOperator
from openapi_client.models.put_building_operator_request import PutBuildingOperatorRequest
from openapi_client.models.put_building_request import PutBuildingRequest
from openapi_client.models.put_room_request import PutRoomRequest
from openapi_client.models.room import Room
from openapi_client.models.tenancy import Tenancy
from openapi_client.models.update_tenancy_request import UpdateTenancyRequest

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def bulk_create_buildings(self, building : Building, **kwargs) -> object:  # noqa: E501
        """bulk_create_buildings  # noqa: E501

        Create buildings in bulk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bulk_create_buildings(building, async_req=True)
        >>> result = thread.get()

        :param building: (required)
        :type building: Building
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the bulk_create_buildings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.bulk_create_buildings_with_http_info(building, **kwargs)  # noqa: E501

    @validate_arguments
    def bulk_create_buildings_with_http_info(self, building : Building, **kwargs) -> ApiResponse:  # noqa: E501
        """bulk_create_buildings  # noqa: E501

        Create buildings in bulk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bulk_create_buildings_with_http_info(building, async_req=True)
        >>> result = thread.get()

        :param building: (required)
        :type building: Building
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'building'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_buildings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['building'] is not None:
            _body_params = _params['building']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/bulk', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def bulk_create_rooms(self, room : Room, **kwargs) -> object:  # noqa: E501
        """bulk_create_rooms  # noqa: E501

        Creates rooms in bulk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bulk_create_rooms(room, async_req=True)
        >>> result = thread.get()

        :param room: (required)
        :type room: Room
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the bulk_create_rooms_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.bulk_create_rooms_with_http_info(room, **kwargs)  # noqa: E501

    @validate_arguments
    def bulk_create_rooms_with_http_info(self, room : Room, **kwargs) -> ApiResponse:  # noqa: E501
        """bulk_create_rooms  # noqa: E501

        Creates rooms in bulk  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bulk_create_rooms_with_http_info(room, async_req=True)
        >>> result = thread.get()

        :param room: (required)
        :type room: Room
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'room'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_rooms" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['room'] is not None:
            _body_params = _params['room']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/bulk', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_building(self, building : Building, **kwargs) -> object:  # noqa: E501
        """create_building  # noqa: E501

        Create a single Building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_building(building, async_req=True)
        >>> result = thread.get()

        :param building: (required)
        :type building: Building
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_building_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_building_with_http_info(building, **kwargs)  # noqa: E501

    @validate_arguments
    def create_building_with_http_info(self, building : Building, **kwargs) -> ApiResponse:  # noqa: E501
        """create_building  # noqa: E501

        Create a single Building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_building_with_http_info(building, async_req=True)
        >>> result = thread.get()

        :param building: (required)
        :type building: Building
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'building'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_building" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['building'] is not None:
            _body_params = _params['building']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_building_operator(self, building_operator : BuildingOperator, **kwargs) -> object:  # noqa: E501
        """create_building_operator  # noqa: E501

        Create a new building operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_building_operator(building_operator, async_req=True)
        >>> result = thread.get()

        :param building_operator: (required)
        :type building_operator: BuildingOperator
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_building_operator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_building_operator_with_http_info(building_operator, **kwargs)  # noqa: E501

    @validate_arguments
    def create_building_operator_with_http_info(self, building_operator : BuildingOperator, **kwargs) -> ApiResponse:  # noqa: E501
        """create_building_operator  # noqa: E501

        Create a new building operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_building_operator_with_http_info(building_operator, async_req=True)
        >>> result = thread.get()

        :param building_operator: (required)
        :type building_operator: BuildingOperator
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'building_operator'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_building_operator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['building_operator'] is not None:
            _body_params = _params['building_operator']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_room(self, room : Room, **kwargs) -> object:  # noqa: E501
        """create_room  # noqa: E501

        Create a new room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_room(room, async_req=True)
        >>> result = thread.get()

        :param room: (required)
        :type room: Room
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_room_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_room_with_http_info(room, **kwargs)  # noqa: E501

    @validate_arguments
    def create_room_with_http_info(self, room : Room, **kwargs) -> ApiResponse:  # noqa: E501
        """create_room  # noqa: E501

        Create a new room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_room_with_http_info(room, async_req=True)
        >>> result = thread.get()

        :param room: (required)
        :type room: Room
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'room'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_room" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['room'] is not None:
            _body_params = _params['room']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_tenancy(self, tenancy : Tenancy, **kwargs) -> object:  # noqa: E501
        """create_tenancy  # noqa: E501

        Create a new Tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_tenancy(tenancy, async_req=True)
        >>> result = thread.get()

        :param tenancy: (required)
        :type tenancy: Tenancy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the create_tenancy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.create_tenancy_with_http_info(tenancy, **kwargs)  # noqa: E501

    @validate_arguments
    def create_tenancy_with_http_info(self, tenancy : Tenancy, **kwargs) -> ApiResponse:  # noqa: E501
        """create_tenancy  # noqa: E501

        Create a new Tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_tenancy_with_http_info(tenancy, async_req=True)
        >>> result = thread.get()

        :param tenancy: (required)
        :type tenancy: Tenancy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'tenancy'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tenancy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['tenancy'] is not None:
            _body_params = _params['tenancy']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_building(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """delete_building  # noqa: E501

        Delete a single Building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_building(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_building_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_building_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_building_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """delete_building  # noqa: E501

        Delete a single Building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_building_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_building" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_building_operator(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """delete_building_operator  # noqa: E501

        Delete a building operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_building_operator(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_building_operator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_building_operator_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_building_operator_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """delete_building_operator  # noqa: E501

        Delete a building operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_building_operator_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_building_operator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_room(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """delete_room  # noqa: E501

        Delete a single Room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_room(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_room_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_room_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_room_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """delete_room  # noqa: E501

        Delete a single Room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_room_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_room" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_tenancy(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """delete_tenancy  # noqa: E501

        Delete a single tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_tenancy(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_tenancy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_tenancy_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_tenancy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """delete_tenancy  # noqa: E501

        Delete a single tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_tenancy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tenancy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_by_id(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> object:  # noqa: E501
        """get_building_by_id  # noqa: E501

        View a single building by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_by_id(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_by_id_with_http_info(id, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_by_id_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_by_id  # noqa: E501

        View a single building by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_by_id_with_http_info(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_operator_by_id(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> object:  # noqa: E501
        """get_building_operator_by_id  # noqa: E501

        View a single Building Operator by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operator_by_id(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_operator_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_operator_by_id_with_http_info(id, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_operator_by_id_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_operator_by_id  # noqa: E501

        View a single Building Operator by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operator_by_id_with_http_info(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_operator_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_operator_with_buildings(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_building_operator_with_buildings  # noqa: E501

        View an operator with its associated buildings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operator_with_buildings(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_operator_with_buildings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_operator_with_buildings_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_operator_with_buildings_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_operator_with_buildings  # noqa: E501

        View an operator with its associated buildings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operator_with_buildings_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_operator_with_buildings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators/{id}/withbuildings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_operators(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, operator_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator name")] = None, operator_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator code")] = None, operator_description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator description")] = None, customer_type_id : Annotated[Optional[StrictInt], Field(description="Enter an integer to filter operators by their customer_type_id")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_building_operators  # noqa: E501

        Returns a list of building operators  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operators(page_size, page, order_by, fields, search_all_fields, id, operator_name, operator_code, operator_description, customer_type_id, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param operator_name: Enter a full or portion of an operator name
        :type operator_name: str
        :param operator_code: Enter a full or portion of an operator code
        :type operator_code: str
        :param operator_description: Enter a full or portion of an operator description
        :type operator_description: str
        :param customer_type_id: Enter an integer to filter operators by their customer_type_id
        :type customer_type_id: int
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_operators_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_operators_with_http_info(page_size, page, order_by, fields, search_all_fields, id, operator_name, operator_code, operator_description, customer_type_id, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_operators_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, operator_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator name")] = None, operator_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator code")] = None, operator_description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator description")] = None, customer_type_id : Annotated[Optional[StrictInt], Field(description="Enter an integer to filter operators by their customer_type_id")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_operators  # noqa: E501

        Returns a list of building operators  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operators_with_http_info(page_size, page, order_by, fields, search_all_fields, id, operator_name, operator_code, operator_description, customer_type_id, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param operator_name: Enter a full or portion of an operator name
        :type operator_name: str
        :param operator_code: Enter a full or portion of an operator code
        :type operator_code: str
        :param operator_description: Enter a full or portion of an operator description
        :type operator_description: str
        :param customer_type_id: Enter an integer to filter operators by their customer_type_id
        :type customer_type_id: int
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'fields',
            'search_all_fields',
            'id',
            'operator_name',
            'operator_code',
            'operator_description',
            'customer_type_id',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_operators" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('operator_name') is not None:  # noqa: E501
            _query_params.append(('operator_name', _params['operator_name']))

        if _params.get('operator_code') is not None:  # noqa: E501
            _query_params.append(('operator_code', _params['operator_code']))

        if _params.get('operator_description') is not None:  # noqa: E501
            _query_params.append(('operator_description', _params['operator_description']))

        if _params.get('customer_type_id') is not None:  # noqa: E501
            _query_params.append(('customer_type_id', _params['customer_type_id']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_operators_with_buildings(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, operator_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator name")] = None, operator_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator code")] = None, operator_description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator description")] = None, customer_type_id : Annotated[Optional[StrictInt], Field(description="Enter an integer to filter operators by their customer_type_id")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_building_operators_with_buildings  # noqa: E501

        View all building operators with their associated buildings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operators_with_buildings(page_size, page, order_by, search_all_fields, id, operator_name, operator_code, operator_description, customer_type_id, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param operator_name: Enter a full or portion of an operator name
        :type operator_name: str
        :param operator_code: Enter a full or portion of an operator code
        :type operator_code: str
        :param operator_description: Enter a full or portion of an operator description
        :type operator_description: str
        :param customer_type_id: Enter an integer to filter operators by their customer_type_id
        :type customer_type_id: int
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_operators_with_buildings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_operators_with_buildings_with_http_info(page_size, page, order_by, search_all_fields, id, operator_name, operator_code, operator_description, customer_type_id, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_operators_with_buildings_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, operator_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator name")] = None, operator_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator code")] = None, operator_description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of an operator description")] = None, customer_type_id : Annotated[Optional[StrictInt], Field(description="Enter an integer to filter operators by their customer_type_id")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_operators_with_buildings  # noqa: E501

        View all building operators with their associated buildings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_operators_with_buildings_with_http_info(page_size, page, order_by, search_all_fields, id, operator_name, operator_code, operator_description, customer_type_id, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param operator_name: Enter a full or portion of an operator name
        :type operator_name: str
        :param operator_code: Enter a full or portion of an operator code
        :type operator_code: str
        :param operator_description: Enter a full or portion of an operator description
        :type operator_description: str
        :param customer_type_id: Enter an integer to filter operators by their customer_type_id
        :type customer_type_id: int
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'operator_name',
            'operator_code',
            'operator_description',
            'customer_type_id',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_operators_with_buildings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('operator_name') is not None:  # noqa: E501
            _query_params.append(('operator_name', _params['operator_name']))

        if _params.get('operator_code') is not None:  # noqa: E501
            _query_params.append(('operator_code', _params['operator_code']))

        if _params.get('operator_description') is not None:  # noqa: E501
            _query_params.append(('operator_description', _params['operator_description']))

        if _params.get('customer_type_id') is not None:  # noqa: E501
            _query_params.append(('customer_type_id', _params['customer_type_id']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators/withbuildings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_with_associations(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_building_with_associations  # noqa: E501

        View a building with its associated operator and rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_with_associations(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_with_associations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_with_associations_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_with_associations_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_with_associations  # noqa: E501

        View a building with its associated operator and rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_with_associations_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_with_associations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}/withassociations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_with_operator(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_building_with_operator  # noqa: E501

        View a building with its associated operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_with_operator(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_with_operator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_with_operator_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_with_operator_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_with_operator  # noqa: E501

        View a building with its associated operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_with_operator_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_with_operator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}/withoperator', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_building_with_rooms(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_building_with_rooms  # noqa: E501

        View a building with its associated rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_with_rooms(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_building_with_rooms_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_building_with_rooms_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_building_with_rooms_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_building_with_rooms  # noqa: E501

        View a building with its associated rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_building_with_rooms_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_building_with_rooms" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}/withrooms', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_buildings(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_buildings  # noqa: E501

        View all buildings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings(page_size, page, order_by, fields, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_buildings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_buildings_with_http_info(page_size, page, order_by, fields, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_buildings_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_buildings  # noqa: E501

        View all buildings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_http_info(page_size, page, order_by, fields, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'fields',
            'search_all_fields',
            'id',
            'building_name',
            'building_code',
            'building_operator',
            'wifi_id',
            'postcode',
            'status',
            'description',
            'go_live_date',
            'address_1',
            'home_account',
            'account_manager',
            'created_at',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_buildings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_name') is not None:  # noqa: E501
            _query_params.append(('building_name', _params['building_name']))

        if _params.get('building_code') is not None:  # noqa: E501
            _query_params.append(('building_code', _params['building_code']))

        if _params.get('building_operator') is not None:  # noqa: E501
            _query_params.append(('building_operator', _params['building_operator']))

        if _params.get('wifi_id') is not None:  # noqa: E501
            _query_params.append(('wifi_id', _params['wifi_id']))

        if _params.get('postcode') is not None:  # noqa: E501
            _query_params.append(('postcode', _params['postcode']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))

        if _params.get('go_live_date') is not None:  # noqa: E501
            if isinstance(_params['go_live_date'], date):
                _query_params.append(('go_live_date', _params['go_live_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('go_live_date', _params['go_live_date']))

        if _params.get('address_1') is not None:  # noqa: E501
            _query_params.append(('address_1', _params['address_1']))

        if _params.get('home_account') is not None:  # noqa: E501
            _query_params.append(('home_account', _params['home_account']))

        if _params.get('account_manager') is not None:  # noqa: E501
            _query_params.append(('account_manager', _params['account_manager']))

        if _params.get('created_at') is not None:  # noqa: E501
            if isinstance(_params['created_at'], datetime):
                _query_params.append(('created_at', _params['created_at'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created_at', _params['created_at']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_buildings_tenancy_history(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, **kwargs) -> object:  # noqa: E501
        """get_buildings_tenancy_history  # noqa: E501

        View a building and its associated rooms and tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_tenancy_history(id, active_tenancies, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_buildings_tenancy_history_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_buildings_tenancy_history_with_http_info(id, active_tenancies, **kwargs)  # noqa: E501

    @validate_arguments
    def get_buildings_tenancy_history_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_buildings_tenancy_history  # noqa: E501

        View a building and its associated rooms and tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_tenancy_history_with_http_info(id, active_tenancies, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'active_tenancies'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_buildings_tenancy_history" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}/history', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_buildings_with_associations(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_buildings_with_associations  # noqa: E501

        View all buildings with their associated operator and rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_associations(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, account_manager, home_account, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_buildings_with_associations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_buildings_with_associations_with_http_info(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, account_manager, home_account, created_at, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_buildings_with_associations_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_buildings_with_associations  # noqa: E501

        View all buildings with their associated operator and rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_associations_with_http_info(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, account_manager, home_account, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'building_name',
            'building_code',
            'building_operator',
            'wifi_id',
            'postcode',
            'status',
            'description',
            'go_live_date',
            'address_1',
            'account_manager',
            'home_account',
            'created_at',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_buildings_with_associations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_name') is not None:  # noqa: E501
            _query_params.append(('building_name', _params['building_name']))

        if _params.get('building_code') is not None:  # noqa: E501
            _query_params.append(('building_code', _params['building_code']))

        if _params.get('building_operator') is not None:  # noqa: E501
            _query_params.append(('building_operator', _params['building_operator']))

        if _params.get('wifi_id') is not None:  # noqa: E501
            _query_params.append(('wifi_id', _params['wifi_id']))

        if _params.get('postcode') is not None:  # noqa: E501
            _query_params.append(('postcode', _params['postcode']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))

        if _params.get('go_live_date') is not None:  # noqa: E501
            if isinstance(_params['go_live_date'], date):
                _query_params.append(('go_live_date', _params['go_live_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('go_live_date', _params['go_live_date']))

        if _params.get('address_1') is not None:  # noqa: E501
            _query_params.append(('address_1', _params['address_1']))

        if _params.get('account_manager') is not None:  # noqa: E501
            _query_params.append(('account_manager', _params['account_manager']))

        if _params.get('home_account') is not None:  # noqa: E501
            _query_params.append(('home_account', _params['home_account']))

        if _params.get('created_at') is not None:  # noqa: E501
            if isinstance(_params['created_at'], datetime):
                _query_params.append(('created_at', _params['created_at'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created_at', _params['created_at']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/withassociations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_buildings_with_operator(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_buildings_with_operator  # noqa: E501

        View all buildings with their associated operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_operator(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_buildings_with_operator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_buildings_with_operator_with_http_info(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_buildings_with_operator_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_buildings_with_operator  # noqa: E501

        View all buildings with their associated operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_operator_with_http_info(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'building_name',
            'building_code',
            'building_operator',
            'wifi_id',
            'postcode',
            'status',
            'description',
            'go_live_date',
            'address_1',
            'home_account',
            'account_manager',
            'created_at',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_buildings_with_operator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_name') is not None:  # noqa: E501
            _query_params.append(('building_name', _params['building_name']))

        if _params.get('building_code') is not None:  # noqa: E501
            _query_params.append(('building_code', _params['building_code']))

        if _params.get('building_operator') is not None:  # noqa: E501
            _query_params.append(('building_operator', _params['building_operator']))

        if _params.get('wifi_id') is not None:  # noqa: E501
            _query_params.append(('wifi_id', _params['wifi_id']))

        if _params.get('postcode') is not None:  # noqa: E501
            _query_params.append(('postcode', _params['postcode']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))

        if _params.get('go_live_date') is not None:  # noqa: E501
            if isinstance(_params['go_live_date'], date):
                _query_params.append(('go_live_date', _params['go_live_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('go_live_date', _params['go_live_date']))

        if _params.get('address_1') is not None:  # noqa: E501
            _query_params.append(('address_1', _params['address_1']))

        if _params.get('home_account') is not None:  # noqa: E501
            _query_params.append(('home_account', _params['home_account']))

        if _params.get('account_manager') is not None:  # noqa: E501
            _query_params.append(('account_manager', _params['account_manager']))

        if _params.get('created_at') is not None:  # noqa: E501
            if isinstance(_params['created_at'], datetime):
                _query_params.append(('created_at', _params['created_at'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created_at', _params['created_at']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/withoperator', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_buildings_with_rooms(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_buildings_with_rooms  # noqa: E501

        View buildings with their associated rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_rooms(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_buildings_with_rooms_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_buildings_with_rooms_with_http_info(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_buildings_with_rooms_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_name : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building name")] = None, building_code : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a building code")] = None, building_operator : Annotated[Optional[StrictInt], Field(description="Enter a building operator id")] = None, wifi_id : Annotated[Optional[StrictStr], Field(description="Enter a wifi_id")] = None, postcode : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a postcode")] = None, status : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a status")] = None, description : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a description")] = None, go_live_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a go live date")] = None, address_1 : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of the address")] = None, home_account : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a home account")] = None, account_manager : Annotated[Optional[StrictStr], Field(description="Enter a full or portion of a account manager")] = None, created_at : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by created_at value")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_buildings_with_rooms  # noqa: E501

        View buildings with their associated rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_buildings_with_rooms_with_http_info(page_size, page, order_by, search_all_fields, id, building_name, building_code, building_operator, wifi_id, postcode, status, description, go_live_date, address_1, home_account, account_manager, created_at, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_name: Enter a full or portion of a building name
        :type building_name: str
        :param building_code: Enter a full or portion of a building code
        :type building_code: str
        :param building_operator: Enter a building operator id
        :type building_operator: int
        :param wifi_id: Enter a wifi_id
        :type wifi_id: str
        :param postcode: Enter a full or portion of a postcode
        :type postcode: str
        :param status: Enter a full or portion of a status
        :type status: str
        :param description: Enter a full or portion of a description
        :type description: str
        :param go_live_date: Enter a ISO8601 formatted date to filter results to match a go live date
        :type go_live_date: date
        :param address_1: Enter a full or portion of the address
        :type address_1: str
        :param home_account: Enter a full or portion of a home account
        :type home_account: str
        :param account_manager: Enter a full or portion of a account manager
        :type account_manager: str
        :param created_at: Enter a ISO8601 DateTime to filter by created_at value
        :type created_at: datetime
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'building_name',
            'building_code',
            'building_operator',
            'wifi_id',
            'postcode',
            'status',
            'description',
            'go_live_date',
            'address_1',
            'home_account',
            'account_manager',
            'created_at',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_buildings_with_rooms" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_name') is not None:  # noqa: E501
            _query_params.append(('building_name', _params['building_name']))

        if _params.get('building_code') is not None:  # noqa: E501
            _query_params.append(('building_code', _params['building_code']))

        if _params.get('building_operator') is not None:  # noqa: E501
            _query_params.append(('building_operator', _params['building_operator']))

        if _params.get('wifi_id') is not None:  # noqa: E501
            _query_params.append(('wifi_id', _params['wifi_id']))

        if _params.get('postcode') is not None:  # noqa: E501
            _query_params.append(('postcode', _params['postcode']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('description') is not None:  # noqa: E501
            _query_params.append(('description', _params['description']))

        if _params.get('go_live_date') is not None:  # noqa: E501
            if isinstance(_params['go_live_date'], date):
                _query_params.append(('go_live_date', _params['go_live_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('go_live_date', _params['go_live_date']))

        if _params.get('address_1') is not None:  # noqa: E501
            _query_params.append(('address_1', _params['address_1']))

        if _params.get('home_account') is not None:  # noqa: E501
            _query_params.append(('home_account', _params['home_account']))

        if _params.get('account_manager') is not None:  # noqa: E501
            _query_params.append(('account_manager', _params['account_manager']))

        if _params.get('created_at') is not None:  # noqa: E501
            if isinstance(_params['created_at'], datetime):
                _query_params.append(('created_at', _params['created_at'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created_at', _params['created_at']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/withrooms', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_room_by_id(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> object:  # noqa: E501
        """get_room_by_id  # noqa: E501

        View a single room by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_room_by_id(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_room_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_room_by_id_with_http_info(id, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_room_by_id_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_room_by_id  # noqa: E501

        View a single room by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_room_by_id_with_http_info(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_room_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_room_with_associations(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, **kwargs) -> object:  # noqa: E501
        """get_room_with_associations  # noqa: E501

        View a room with its associated building and tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_room_with_associations(id, active_tenancies, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_room_with_associations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_room_with_associations_with_http_info(id, active_tenancies, **kwargs)  # noqa: E501

    @validate_arguments
    def get_room_with_associations_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_room_with_associations  # noqa: E501

        View a room with its associated building and tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_room_with_associations_with_http_info(id, active_tenancies, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'active_tenancies'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_room_with_associations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}/withassociations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_room_with_tenancies(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, **kwargs) -> object:  # noqa: E501
        """get_room_with_tenancies  # noqa: E501

        View a room with its associated tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_room_with_tenancies(id, active_tenancies, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_room_with_tenancies_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_room_with_tenancies_with_http_info(id, active_tenancies, **kwargs)  # noqa: E501

    @validate_arguments
    def get_room_with_tenancies_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_room_with_tenancies  # noqa: E501

        View a room with its associated tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_room_with_tenancies_with_http_info(id, active_tenancies, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'active_tenancies'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_room_with_tenancies" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}/withtenancies', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_rooms(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_rooms  # noqa: E501

        View all rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms(page_size, page, order_by, fields, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_rooms_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_rooms_with_http_info(page_size, page, order_by, fields, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_rooms_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_rooms  # noqa: E501

        View all rooms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_http_info(page_size, page, order_by, fields, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'fields',
            'search_all_fields',
            'id',
            'building_id',
            'room_number',
            'default_vlan',
            'current_vlan',
            'is_active',
            'is_virtual',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rooms" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_id') is not None:  # noqa: E501
            _query_params.append(('building_id', _params['building_id']))

        if _params.get('room_number') is not None:  # noqa: E501
            _query_params.append(('room_number', _params['room_number']))

        if _params.get('default_vlan') is not None:  # noqa: E501
            _query_params.append(('default_vlan', _params['default_vlan']))

        if _params.get('current_vlan') is not None:  # noqa: E501
            _query_params.append(('current_vlan', _params['current_vlan']))

        if _params.get('is_active') is not None:  # noqa: E501
            _query_params.append(('is_active', _params['is_active']))

        if _params.get('is_virtual') is not None:  # noqa: E501
            _query_params.append(('is_virtual', _params['is_virtual']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_rooms_with_associations(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_rooms_with_associations  # noqa: E501

        View all rooms with their associated building and tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_associations(page_size, page, order_by, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_rooms_with_associations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_rooms_with_associations_with_http_info(page_size, page, order_by, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, active_tenancies, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_rooms_with_associations_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_rooms_with_associations  # noqa: E501

        View all rooms with their associated building and tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_associations_with_http_info(page_size, page, order_by, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'building_id',
            'room_number',
            'default_vlan',
            'current_vlan',
            'is_active',
            'is_virtual',
            'active_tenancies',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rooms_with_associations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_id') is not None:  # noqa: E501
            _query_params.append(('building_id', _params['building_id']))

        if _params.get('room_number') is not None:  # noqa: E501
            _query_params.append(('room_number', _params['room_number']))

        if _params.get('default_vlan') is not None:  # noqa: E501
            _query_params.append(('default_vlan', _params['default_vlan']))

        if _params.get('current_vlan') is not None:  # noqa: E501
            _query_params.append(('current_vlan', _params['current_vlan']))

        if _params.get('is_active') is not None:  # noqa: E501
            _query_params.append(('is_active', _params['is_active']))

        if _params.get('is_virtual') is not None:  # noqa: E501
            _query_params.append(('is_virtual', _params['is_virtual']))

        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/withassociations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_rooms_with_building(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_rooms_with_building  # noqa: E501

        View all rooms with their associated building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_building(page_size, page, order_by, search_all_fields, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_rooms_with_building_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_rooms_with_building_with_http_info(page_size, page, order_by, search_all_fields, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_rooms_with_building_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_rooms_with_building  # noqa: E501

        View all rooms with their associated building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_building_with_http_info(page_size, page, order_by, search_all_fields, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'building_id',
            'room_number',
            'default_vlan',
            'current_vlan',
            'is_active',
            'is_virtual',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rooms_with_building" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('building_id') is not None:  # noqa: E501
            _query_params.append(('building_id', _params['building_id']))

        if _params.get('room_number') is not None:  # noqa: E501
            _query_params.append(('room_number', _params['room_number']))

        if _params.get('default_vlan') is not None:  # noqa: E501
            _query_params.append(('default_vlan', _params['default_vlan']))

        if _params.get('current_vlan') is not None:  # noqa: E501
            _query_params.append(('current_vlan', _params['current_vlan']))

        if _params.get('is_active') is not None:  # noqa: E501
            _query_params.append(('is_active', _params['is_active']))

        if _params.get('is_virtual') is not None:  # noqa: E501
            _query_params.append(('is_virtual', _params['is_virtual']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/withbuilding', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_rooms_with_building_0(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_rooms_with_building_0  # noqa: E501

        View a room with its associated building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_building_0(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_rooms_with_building_0_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_rooms_with_building_0_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_rooms_with_building_0_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_rooms_with_building_0  # noqa: E501

        View a room with its associated building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_building_0_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rooms_with_building_0" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}/withbuilding', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_rooms_with_tenancies(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_rooms_with_tenancies  # noqa: E501

        View all rooms with their associated tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_tenancies(page_size, page, order_by, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_rooms_with_tenancies_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_rooms_with_tenancies_with_http_info(page_size, page, order_by, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, active_tenancies, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_rooms_with_tenancies_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, room_number : Annotated[Optional[StrictStr], Field(description="Enter a room number")] = None, default_vlan : Annotated[Optional[StrictInt], Field(description="Enter a default vlan")] = None, current_vlan : Annotated[Optional[StrictInt], Field(description="Enter a current vlan")] = None, is_active : Annotated[Optional[StrictBool], Field(description="Search for active or inactive rooms")] = None, is_virtual : Annotated[Optional[StrictBool], Field(description="Search for standard or virtual rooms")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_rooms_with_tenancies  # noqa: E501

        View all rooms with their associated tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_rooms_with_tenancies_with_http_info(page_size, page, order_by, search_all_fields, id, building_id, room_number, default_vlan, current_vlan, is_active, is_virtual, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param building_id: Enter a building id
        :type building_id: int
        :param room_number: Enter a room number
        :type room_number: str
        :param default_vlan: Enter a default vlan
        :type default_vlan: int
        :param current_vlan: Enter a current vlan
        :type current_vlan: int
        :param is_active: Search for active or inactive rooms
        :type is_active: bool
        :param is_virtual: Search for standard or virtual rooms
        :type is_virtual: bool
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'building_id',
            'room_number',
            'default_vlan',
            'current_vlan',
            'is_active',
            'is_virtual',
            'active_tenancies',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rooms_with_tenancies" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('building_id') is not None:  # noqa: E501
            _query_params.append(('building_id', _params['building_id']))

        if _params.get('room_number') is not None:  # noqa: E501
            _query_params.append(('room_number', _params['room_number']))

        if _params.get('default_vlan') is not None:  # noqa: E501
            _query_params.append(('default_vlan', _params['default_vlan']))

        if _params.get('current_vlan') is not None:  # noqa: E501
            _query_params.append(('current_vlan', _params['current_vlan']))

        if _params.get('is_active') is not None:  # noqa: E501
            _query_params.append(('is_active', _params['is_active']))

        if _params.get('is_virtual') is not None:  # noqa: E501
            _query_params.append(('is_virtual', _params['is_virtual']))

        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/withtenancies', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_tenancies(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, room_id : Annotated[Optional[StrictInt], Field(description="Enter a room id")] = None, start_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a start date")] = None, end_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a end date")] = None, tenant_id : Annotated[Optional[StrictStr], Field(description="Enter a tenant id")] = None, start_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, start_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date")] = None, start_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date")] = None, end_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, end_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date")] = None, end_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_tenancies  # noqa: E501

        View all tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancies(page_size, page, order_by, fields, search_all_fields, id, room_id, start_date, end_date, tenant_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param room_id: Enter a room id
        :type room_id: int
        :param start_date: Enter a ISO8601 formatted date to filter results to match a start date
        :type start_date: date
        :param end_date: Enter a ISO8601 formatted date to filter results to match a end date
        :type end_date: date
        :param tenant_id: Enter a tenant id
        :type tenant_id: str
        :param start_source: Enter a string to filter results by a specific value
        :type start_source: str
        :param start_date_from: Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date
        :type start_date_from: date
        :param start_date_to: Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date
        :type start_date_to: date
        :param end_source: Enter a string to filter results by a specific value
        :type end_source: str
        :param end_date_from: Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date
        :type end_date_from: date
        :param end_date_to: Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date
        :type end_date_to: date
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_tenancies_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_tenancies_with_http_info(page_size, page, order_by, fields, search_all_fields, id, room_id, start_date, end_date, tenant_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tenancies_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, room_id : Annotated[Optional[StrictInt], Field(description="Enter a room id")] = None, start_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a start date")] = None, end_date : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results to match a end date")] = None, tenant_id : Annotated[Optional[StrictStr], Field(description="Enter a tenant id")] = None, start_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, start_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date")] = None, start_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date")] = None, end_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, end_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date")] = None, end_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_tenancies  # noqa: E501

        View all tenancies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancies_with_http_info(page_size, page, order_by, fields, search_all_fields, id, room_id, start_date, end_date, tenant_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param room_id: Enter a room id
        :type room_id: int
        :param start_date: Enter a ISO8601 formatted date to filter results to match a start date
        :type start_date: date
        :param end_date: Enter a ISO8601 formatted date to filter results to match a end date
        :type end_date: date
        :param tenant_id: Enter a tenant id
        :type tenant_id: str
        :param start_source: Enter a string to filter results by a specific value
        :type start_source: str
        :param start_date_from: Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date
        :type start_date_from: date
        :param start_date_to: Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date
        :type start_date_to: date
        :param end_source: Enter a string to filter results by a specific value
        :type end_source: str
        :param end_date_from: Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date
        :type end_date_from: date
        :param end_date_to: Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date
        :type end_date_to: date
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'fields',
            'search_all_fields',
            'id',
            'room_id',
            'start_date',
            'end_date',
            'tenant_id',
            'start_source',
            'start_date_from',
            'start_date_to',
            'end_source',
            'end_date_from',
            'end_date_to',
            'active_tenancies',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tenancies" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('room_id') is not None:  # noqa: E501
            _query_params.append(('room_id', _params['room_id']))

        if _params.get('start_date') is not None:  # noqa: E501
            if isinstance(_params['start_date'], date):
                _query_params.append(('start_date', _params['start_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date', _params['start_date']))

        if _params.get('end_date') is not None:  # noqa: E501
            if isinstance(_params['end_date'], date):
                _query_params.append(('end_date', _params['end_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date', _params['end_date']))

        if _params.get('tenant_id') is not None:  # noqa: E501
            _query_params.append(('tenant_id', _params['tenant_id']))

        if _params.get('start_source') is not None:  # noqa: E501
            _query_params.append(('start_source', _params['start_source']))

        if _params.get('start_date_from') is not None:  # noqa: E501
            if isinstance(_params['start_date_from'], date):
                _query_params.append(('start_date_from', _params['start_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date_from', _params['start_date_from']))

        if _params.get('start_date_to') is not None:  # noqa: E501
            if isinstance(_params['start_date_to'], date):
                _query_params.append(('start_date_to', _params['start_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date_to', _params['start_date_to']))

        if _params.get('end_source') is not None:  # noqa: E501
            _query_params.append(('end_source', _params['end_source']))

        if _params.get('end_date_from') is not None:  # noqa: E501
            if isinstance(_params['end_date_from'], date):
                _query_params.append(('end_date_from', _params['end_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date_from', _params['end_date_from']))

        if _params.get('end_date_to') is not None:  # noqa: E501
            if isinstance(_params['end_date_to'], date):
                _query_params.append(('end_date_to', _params['end_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date_to', _params['end_date_to']))

        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_tenancies_with_associations(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, room_id : Annotated[Optional[StrictInt], Field(description="Enter a room id")] = None, tenant_id : Annotated[Optional[StrictStr], Field(description="Enter a tenant id")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, start_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, start_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date")] = None, start_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date")] = None, end_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, end_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date")] = None, end_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_tenancies_with_associations  # noqa: E501

        View all tenancies with their associated room and building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancies_with_associations(page_size, page, order_by, search_all_fields, id, room_id, tenant_id, building_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param room_id: Enter a room id
        :type room_id: int
        :param tenant_id: Enter a tenant id
        :type tenant_id: str
        :param building_id: Enter a building id
        :type building_id: int
        :param start_source: Enter a string to filter results by a specific value
        :type start_source: str
        :param start_date_from: Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date
        :type start_date_from: date
        :param start_date_to: Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date
        :type start_date_to: date
        :param end_source: Enter a string to filter results by a specific value
        :type end_source: str
        :param end_date_from: Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date
        :type end_date_from: date
        :param end_date_to: Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date
        :type end_date_to: date
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_tenancies_with_associations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_tenancies_with_associations_with_http_info(page_size, page, order_by, search_all_fields, id, room_id, tenant_id, building_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tenancies_with_associations_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, room_id : Annotated[Optional[StrictInt], Field(description="Enter a room id")] = None, tenant_id : Annotated[Optional[StrictStr], Field(description="Enter a tenant id")] = None, building_id : Annotated[Optional[StrictInt], Field(description="Enter a building id")] = None, start_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, start_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date")] = None, start_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date")] = None, end_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, end_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date")] = None, end_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_tenancies_with_associations  # noqa: E501

        View all tenancies with their associated room and building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancies_with_associations_with_http_info(page_size, page, order_by, search_all_fields, id, room_id, tenant_id, building_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param room_id: Enter a room id
        :type room_id: int
        :param tenant_id: Enter a tenant id
        :type tenant_id: str
        :param building_id: Enter a building id
        :type building_id: int
        :param start_source: Enter a string to filter results by a specific value
        :type start_source: str
        :param start_date_from: Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date
        :type start_date_from: date
        :param start_date_to: Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date
        :type start_date_to: date
        :param end_source: Enter a string to filter results by a specific value
        :type end_source: str
        :param end_date_from: Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date
        :type end_date_from: date
        :param end_date_to: Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date
        :type end_date_to: date
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'room_id',
            'tenant_id',
            'building_id',
            'start_source',
            'start_date_from',
            'start_date_to',
            'end_source',
            'end_date_from',
            'end_date_to',
            'active_tenancies',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tenancies_with_associations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('room_id') is not None:  # noqa: E501
            _query_params.append(('room_id', _params['room_id']))

        if _params.get('tenant_id') is not None:  # noqa: E501
            _query_params.append(('tenant_id', _params['tenant_id']))

        if _params.get('building_id') is not None:  # noqa: E501
            _query_params.append(('building_id', _params['building_id']))

        if _params.get('start_source') is not None:  # noqa: E501
            _query_params.append(('start_source', _params['start_source']))

        if _params.get('start_date_from') is not None:  # noqa: E501
            if isinstance(_params['start_date_from'], date):
                _query_params.append(('start_date_from', _params['start_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date_from', _params['start_date_from']))

        if _params.get('start_date_to') is not None:  # noqa: E501
            if isinstance(_params['start_date_to'], date):
                _query_params.append(('start_date_to', _params['start_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date_to', _params['start_date_to']))

        if _params.get('end_source') is not None:  # noqa: E501
            _query_params.append(('end_source', _params['end_source']))

        if _params.get('end_date_from') is not None:  # noqa: E501
            if isinstance(_params['end_date_from'], date):
                _query_params.append(('end_date_from', _params['end_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date_from', _params['end_date_from']))

        if _params.get('end_date_to') is not None:  # noqa: E501
            if isinstance(_params['end_date_to'], date):
                _query_params.append(('end_date_to', _params['end_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date_to', _params['end_date_to']))

        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/withassociations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_tenancies_with_room(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, tenant_id : Annotated[Optional[StrictStr], Field(description="Enter a tenant id")] = None, room_id : Annotated[Optional[StrictInt], Field(description="Enter a room id")] = None, start_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, start_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date")] = None, start_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date")] = None, end_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, end_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date")] = None, end_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> object:  # noqa: E501
        """get_tenancies_with_room  # noqa: E501

        View all tenancies with their associated room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancies_with_room(page_size, page, order_by, search_all_fields, id, tenant_id, room_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param tenant_id: Enter a tenant id
        :type tenant_id: str
        :param room_id: Enter a room id
        :type room_id: int
        :param start_source: Enter a string to filter results by a specific value
        :type start_source: str
        :param start_date_from: Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date
        :type start_date_from: date
        :param start_date_to: Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date
        :type start_date_to: date
        :param end_source: Enter a string to filter results by a specific value
        :type end_source: str
        :param end_date_from: Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date
        :type end_date_from: date
        :param end_date_to: Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date
        :type end_date_to: date
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_tenancies_with_room_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_tenancies_with_room_with_http_info(page_size, page, order_by, search_all_fields, id, tenant_id, room_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tenancies_with_room_with_http_info(self, page_size : Annotated[Optional[StrictInt], Field(description="Enter a quantity of items to a page.")] = None, page : Annotated[Optional[StrictInt], Field(description="Enter the page number to be returned")] = None, order_by : Annotated[Optional[StrictStr], Field(description="Enter a single field name followed by Ascending(ASC) or Descending (DESC)")] = None, search_all_fields : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific field")] = None, id : Annotated[Optional[StrictInt], Field(description="Enter a specific record id for the given resource")] = None, tenant_id : Annotated[Optional[StrictStr], Field(description="Enter a tenant id")] = None, room_id : Annotated[Optional[StrictInt], Field(description="Enter a room id")] = None, start_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, start_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date")] = None, start_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date")] = None, end_source : Annotated[Optional[StrictStr], Field(description="Enter a string to filter results by a specific value")] = None, end_date_from : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date")] = None, end_date_to : Annotated[Optional[date], Field(description="Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date")] = None, active_tenancies : Annotated[Optional[StrictBool], Field(description="Filter tenancies to either active or inactive")] = None, last_updated : Annotated[Optional[datetime], Field(description="Enter a ISO8601 DateTime to filter by last_updated value")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_tenancies_with_room  # noqa: E501

        View all tenancies with their associated room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancies_with_room_with_http_info(page_size, page, order_by, search_all_fields, id, tenant_id, room_id, start_source, start_date_from, start_date_to, end_source, end_date_from, end_date_to, active_tenancies, last_updated, async_req=True)
        >>> result = thread.get()

        :param page_size: Enter a quantity of items to a page.
        :type page_size: int
        :param page: Enter the page number to be returned
        :type page: int
        :param order_by: Enter a single field name followed by Ascending(ASC) or Descending (DESC)
        :type order_by: str
        :param search_all_fields: Enter a string to filter results by a specific field
        :type search_all_fields: str
        :param id: Enter a specific record id for the given resource
        :type id: int
        :param tenant_id: Enter a tenant id
        :type tenant_id: str
        :param room_id: Enter a room id
        :type room_id: int
        :param start_source: Enter a string to filter results by a specific value
        :type start_source: str
        :param start_date_from: Enter a ISO8601 formatted date to filter results that have a start date value on or after the specified date
        :type start_date_from: date
        :param start_date_to: Enter a ISO8601 formatted date to filter results that have a start date value on or before the specified date
        :type start_date_to: date
        :param end_source: Enter a string to filter results by a specific value
        :type end_source: str
        :param end_date_from: Enter a ISO8601 formatted date to filter results that have a end date value on or after the specified date
        :type end_date_from: date
        :param end_date_to: Enter a ISO8601 formatted date to filter results that have a end date value on or before the specified date
        :type end_date_to: date
        :param active_tenancies: Filter tenancies to either active or inactive
        :type active_tenancies: bool
        :param last_updated: Enter a ISO8601 DateTime to filter by last_updated value
        :type last_updated: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'page_size',
            'page',
            'order_by',
            'search_all_fields',
            'id',
            'tenant_id',
            'room_id',
            'start_source',
            'start_date_from',
            'start_date_to',
            'end_source',
            'end_date_from',
            'end_date_to',
            'active_tenancies',
            'last_updated'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tenancies_with_room" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('page_size', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('order_by', _params['order_by']))

        if _params.get('search_all_fields') is not None:  # noqa: E501
            _query_params.append(('search_all_fields', _params['search_all_fields']))

        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        if _params.get('tenant_id') is not None:  # noqa: E501
            _query_params.append(('tenant_id', _params['tenant_id']))

        if _params.get('room_id') is not None:  # noqa: E501
            _query_params.append(('room_id', _params['room_id']))

        if _params.get('start_source') is not None:  # noqa: E501
            _query_params.append(('start_source', _params['start_source']))

        if _params.get('start_date_from') is not None:  # noqa: E501
            if isinstance(_params['start_date_from'], date):
                _query_params.append(('start_date_from', _params['start_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date_from', _params['start_date_from']))

        if _params.get('start_date_to') is not None:  # noqa: E501
            if isinstance(_params['start_date_to'], date):
                _query_params.append(('start_date_to', _params['start_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('start_date_to', _params['start_date_to']))

        if _params.get('end_source') is not None:  # noqa: E501
            _query_params.append(('end_source', _params['end_source']))

        if _params.get('end_date_from') is not None:  # noqa: E501
            if isinstance(_params['end_date_from'], date):
                _query_params.append(('end_date_from', _params['end_date_from'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date_from', _params['end_date_from']))

        if _params.get('end_date_to') is not None:  # noqa: E501
            if isinstance(_params['end_date_to'], date):
                _query_params.append(('end_date_to', _params['end_date_to'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('end_date_to', _params['end_date_to']))

        if _params.get('active_tenancies') is not None:  # noqa: E501
            _query_params.append(('active_tenancies', _params['active_tenancies']))

        if _params.get('last_updated') is not None:  # noqa: E501
            if isinstance(_params['last_updated'], datetime):
                _query_params.append(('last_updated', _params['last_updated'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('last_updated', _params['last_updated']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/withroom', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_tenancy_by_id(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> object:  # noqa: E501
        """get_tenancy_by_id  # noqa: E501

        View a single tenancy by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancy_by_id(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_tenancy_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_tenancy_by_id_with_http_info(id, fields, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tenancy_by_id_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], fields : Annotated[Optional[StrictStr], Field(description="List which fields names are to be included in the response (comma seperated)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_tenancy_by_id  # noqa: E501

        View a single tenancy by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancy_by_id_with_http_info(id, fields, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param fields: List which fields names are to be included in the response (comma seperated)
        :type fields: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tenancy_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('fields') is not None:  # noqa: E501
            _query_params.append(('fields', _params['fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_tenancy_with_associations(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_tenancy_with_associations  # noqa: E501

        View a tenancy with its associated room and building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancy_with_associations(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_tenancy_with_associations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_tenancy_with_associations_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tenancy_with_associations_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_tenancy_with_associations  # noqa: E501

        View a tenancy with its associated room and building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancy_with_associations_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tenancy_with_associations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/{id}/withassociations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_tenancy_with_room(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> object:  # noqa: E501
        """get_tenancy_with_room  # noqa: E501

        View a tenancy with its associated room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancy_with_room(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_tenancy_with_room_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_tenancy_with_room_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_tenancy_with_room_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_tenancy_with_room  # noqa: E501

        View a tenancy with its associated room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_tenancy_with_room_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tenancy_with_room" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/{id}/withroom', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def put_building(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], put_building_request : PutBuildingRequest, **kwargs) -> object:  # noqa: E501
        """put_building  # noqa: E501

        Create or update building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_building(id, put_building_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param put_building_request: (required)
        :type put_building_request: PutBuildingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_building_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.put_building_with_http_info(id, put_building_request, **kwargs)  # noqa: E501

    @validate_arguments
    def put_building_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], put_building_request : PutBuildingRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """put_building  # noqa: E501

        Create or update building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_building_with_http_info(id, put_building_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param put_building_request: (required)
        :type put_building_request: PutBuildingRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'put_building_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_building" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['put_building_request'] is not None:
            _body_params = _params['put_building_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def put_building_operator(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], put_building_operator_request : PutBuildingOperatorRequest, **kwargs) -> object:  # noqa: E501
        """put_building_operator  # noqa: E501

        Create or update building operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_building_operator(id, put_building_operator_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param put_building_operator_request: (required)
        :type put_building_operator_request: PutBuildingOperatorRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_building_operator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.put_building_operator_with_http_info(id, put_building_operator_request, **kwargs)  # noqa: E501

    @validate_arguments
    def put_building_operator_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], put_building_operator_request : PutBuildingOperatorRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """put_building_operator  # noqa: E501

        Create or update building operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_building_operator_with_http_info(id, put_building_operator_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param put_building_operator_request: (required)
        :type put_building_operator_request: PutBuildingOperatorRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'put_building_operator_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_building_operator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['put_building_operator_request'] is not None:
            _body_params = _params['put_building_operator_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators/{id}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def put_room(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], put_room_request : PutRoomRequest, **kwargs) -> object:  # noqa: E501
        """put_room  # noqa: E501

        Create or update a room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_room(id, put_room_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param put_room_request: (required)
        :type put_room_request: PutRoomRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_room_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.put_room_with_http_info(id, put_room_request, **kwargs)  # noqa: E501

    @validate_arguments
    def put_room_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], put_room_request : PutRoomRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """put_room  # noqa: E501

        Create or update a room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_room_with_http_info(id, put_room_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param put_room_request: (required)
        :type put_room_request: PutRoomRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'put_room_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_room" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['put_room_request'] is not None:
            _body_params = _params['put_room_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_building(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], building : Building, **kwargs) -> object:  # noqa: E501
        """update_building  # noqa: E501

        Update a single building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_building(id, building, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param building: (required)
        :type building: Building
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_building_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_building_with_http_info(id, building, **kwargs)  # noqa: E501

    @validate_arguments
    def update_building_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], building : Building, **kwargs) -> ApiResponse:  # noqa: E501
        """update_building  # noqa: E501

        Update a single building  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_building_with_http_info(id, building, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param building: (required)
        :type building: Building
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'building'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_building" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['building'] is not None:
            _body_params = _params['building']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': None,
            '404': "object",
        }

        return self.api_client.call_api(
            '/buildings/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_building_operator(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], building_operator : BuildingOperator, **kwargs) -> object:  # noqa: E501
        """update_building_operator  # noqa: E501

        Update a single Building Operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_building_operator(id, building_operator, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param building_operator: (required)
        :type building_operator: BuildingOperator
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_building_operator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_building_operator_with_http_info(id, building_operator, **kwargs)  # noqa: E501

    @validate_arguments
    def update_building_operator_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], building_operator : BuildingOperator, **kwargs) -> ApiResponse:  # noqa: E501
        """update_building_operator  # noqa: E501

        Update a single Building Operator  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_building_operator_with_http_info(id, building_operator, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param building_operator: (required)
        :type building_operator: BuildingOperator
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'building_operator'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_building_operator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['building_operator'] is not None:
            _body_params = _params['building_operator']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/operators/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_room(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], room : Room, **kwargs) -> object:  # noqa: E501
        """update_room  # noqa: E501

        Updates a single Room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_room(id, room, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param room: (required)
        :type room: Room
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_room_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_room_with_http_info(id, room, **kwargs)  # noqa: E501

    @validate_arguments
    def update_room_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], room : Room, **kwargs) -> ApiResponse:  # noqa: E501
        """update_room  # noqa: E501

        Updates a single Room  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_room_with_http_info(id, room, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param room: (required)
        :type room: Room
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'room'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['room'] is not None:
            _body_params = _params['room']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/rooms/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_tenancy(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], update_tenancy_request : UpdateTenancyRequest, **kwargs) -> object:  # noqa: E501
        """update_tenancy  # noqa: E501

        Update or create a single Tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_tenancy(id, update_tenancy_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param update_tenancy_request: (required)
        :type update_tenancy_request: UpdateTenancyRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_tenancy_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_tenancy_with_http_info(id, update_tenancy_request, **kwargs)  # noqa: E501

    @validate_arguments
    def update_tenancy_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], update_tenancy_request : UpdateTenancyRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """update_tenancy  # noqa: E501

        Update or create a single Tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_tenancy_with_http_info(id, update_tenancy_request, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param update_tenancy_request: (required)
        :type update_tenancy_request: UpdateTenancyRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'update_tenancy_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tenancy" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_tenancy_request'] is not None:
            _body_params = _params['update_tenancy_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '201': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/{id}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_tenancy_0(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], tenancy : Tenancy, **kwargs) -> object:  # noqa: E501
        """update_tenancy_0  # noqa: E501

        Update a single Tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_tenancy_0(id, tenancy, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param tenancy: (required)
        :type tenancy: Tenancy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_tenancy_0_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_tenancy_0_with_http_info(id, tenancy, **kwargs)  # noqa: E501

    @validate_arguments
    def update_tenancy_0_with_http_info(self, id : Annotated[StrictInt, Field(..., description="Enter a specific record id for the given resource")], tenancy : Tenancy, **kwargs) -> ApiResponse:  # noqa: E501
        """update_tenancy_0  # noqa: E501

        Update a single Tenancy  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_tenancy_0_with_http_info(id, tenancy, async_req=True)
        >>> result = thread.get()

        :param id: Enter a specific record id for the given resource (required)
        :type id: int
        :param tenancy: (required)
        :type tenancy: Tenancy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'tenancy'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tenancy_0" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['tenancy'] is not None:
            _body_params = _params['tenancy']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "object",
            '401': "object",
            '404': "object",
        }

        return self.api_client.call_api(
            '/tenancies/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
